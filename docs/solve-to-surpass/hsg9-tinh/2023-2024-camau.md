---
tags:
    - đếm ký tự
    - chuỗi
    - mảng tần số
    - giá trị lớn nhất
    - sàng nguyên tố Eratosthenes
    - tổng tiền tố
---

# Học sinh giỏi 9 Cà Mau 2023 - 2024

## Bài 1: Đếm ký tự

### Đề bài

Xâu là dãy liên tiếp các ký tự, bao gồm chữ Latin, chữ số và dấu cách.

**Yêu cầu:** Cho xâu $S$ có $N$ ký tự chỉ chứa ký tự chữ Latin và in thường. Hãy đếm số lần xuất hiện của các ký tự có trong xâu $S$.

**Đầu vào:** demkitu.inp

Gồm một dòng duy nhất chứa xâu $S$ có $N$ ký tự $(1 \le N \le 10^6)$.

**Đầu ra:** demkitu.out

Gồm nhiều dòng, mỗi dòng gồm hai kết quả lần lượt là ký tự và số lần xuất hiện của nó trong xâu S, ngăn cách nhau bởi một một khoảng trắng. Các ký tự được sắp xếp theo thứ tự alphabet.

**Ví dụ:**

| demkitu.inp | demkitu.out |
| --- | --- |
| dbakabk | a 2 <br> b 2 <br> d 1 <br> k 2 <br> |

### Bài giải đề xuất

??? tip "Ý tưởng chính"

    Sử dụng mảng tần số `f` để ghi nhận số lần xuất hiện của mỗi ký tự.

    Lợi ích của mảng tần số `f`:

    - Hiệu quả về bộ nhớ.
    - Khi thực hiện đếm, chỉ cần một vòng lặp.
    - Tốc độ truy xuất là $O(1)$ khi cập nhật số lần xuất hiện của một ký tự.
    - Dễ dàng xuất kết quả theo thứ tự bảng chữ cái.

??? tip "Viết chương trình"

    1\. Khởi tạo mảng tần số `f` gồm 26 phần tử (ứng với 26 ký tự từ a đến z), mang giá trị 0, tức chưa xuất hiện lần nào.

    === "C++"

        ```c++ linenums="12"
        int f[26] = {0};
        ```

    === "Python"

        ```py linenums="10"
        f = [0] * 26
        ```

    2\. Duyệt từng ký tự trong chuỗi và cập nhật số lần xuất hiện của nó vào mảng `f`.

    === "C++"

        ```c++ linenums="26"
            // Duyệt từng ký tự c của chuỗi s
            for (char c : s)
            {
                if (c >= 'a' && c <= 'z')
                {
                    // Nếu c là ký tự a..z thì cập nhật số lần xuất hiện của nó
                    f[c - 'a']++;
                }
            }
        ```

    === "Python"

        ```py linenums="24"
            # Duyệt từng ký tự c của chuỗi s
            for c in s:
                # Nếu c là ký tự a..z thì cập nhật số lần xuất hiện của nó
                f[ord(c) - ord('a')] += 1
        ```

### Mã nguồn

Code đầy đủ được đặt tại [GitHub](https://github.com/vtchitruong/hsg/tree/main/hsg9-tinh/2023-2024-camau/demkitu){:target="_blank"}.

## Bài 2: Trò chơi

### Đề bài

Có tất cả m câu hỏi và n đội chơi tham gia. Câu hỏi thứ $i (1 \le i \le m)$, đội thứ $j (1 \le j \le n)$ sẽ được ban giám khảo cho điểm là $a_{ij}$.

Sau trò chơi, đội chiến thắng là đội có tổng số điểm của m câu hỏi là cao nhất.

**Yêu cầu:** Hãy giúp ban tổ chức tìm ra đội chiến thắng và tổng số điểm của đội đó.

**Đầu vào:** trochoi.inp

- Dòng đầu chứa hai số nguyên $m, n (1 \le m, n \le 10^3)$.

- $m$ dòng sau, mỗi dòng chứa $n$ số nguyên $a_{ij} (1 \le a_{ij} \le 10^6)$ thể hiện số điểm câu hỏi thứ $i$ của đội thứ $j$, các số được ngăn cách nhau bởi một khoảng trắng.

Dữ liệu vào bảo đảm chỉ có duy nhất một đội chiến thắng.

**Đầu ra:** trochoi.out

Gồm một dòng duy nhất chứa hai số nguyên lần lượt là số thứ tự và tổng số điểm của đội chiến thắng.

**Ví dụ:**

| trochoi.inp | trochoi.out |
| --- | --- |
| 4 5 <br> 2 5 4 1 2 <br> 4 6 7 3 3 <br> 6 9 5 4 3 <br> 3 8 1 2 4 | 2 28 |

Giải thích:

- Có 4 câu hỏi và 5 đội chơi.
- Số điểm 4 câu hỏi của đội 1 lần lượt là 2, 4, 6 và 3. Tổng điểm là 15.
- Tương tự, tổng số điểm của đội 2, đội 3, đội 4 và đội 5 lần lượt là: 28, 17, 10 và 12.

Đội 2 là đội chiến thắng với 28 điểm.

### Bài giải đề xuất

??? tip "Ý tưởng chính"

    Mỗi dòng trong input là điểm của các đội trong cùng một câu hỏi.

    Cho nên, ta dùng mảng `total` để lưu tổng điểm của từng đội, với `total[i]` là tổng điểm của đội `i`. Ứng với mỗi dòng đọc vào, ta cộng dồn điểm vào `total[i]`.

    Duyệt mảng `total`, ta tìm được điểm cao nhất.

??? tip "Viết chương trình"

    1\. Vừa đọc vừa cập nhật mảng `total`.

    === "C++"

        ```c++ linenums="31"
            cin >> number_of_questions >> number_of_teams;

            // Khởi tạo mảng lưu tổng điểm của mỗi đội
            total.resize(number_of_teams, 0);

            int score;

            // Duyệt từng câu hỏi (từng hàng)
            for (int q = 0; q < number_of_questions; ++q)
            {
                // Duyệt từng đội (từng cột)
                for (int t = 0; t < number_of_teams; ++t)
                {
                    cin >> score;

                    // Cộng dồn điểm cho từng đội
                    total[t] += score;
                }
            }
        ```

    === "Python"

        ```py linenums="26"
            with open(input_file, 'r') as f:
                number_of_questions, number_of_teams = map(int, f.readline().split())

                # Khởi tạo mảng lưu tổng điểm của mỗi đội
                total = [0] * number_of_teams

                # Duyệt từng câu hỏi (từng hàng)
                for q in range(number_of_questions):
                    line = f.readline().split()

                    # Duyệt từng đội (từng cột)
                    for t in range(number_of_teams):
                        score = int(line[t])

                        # Cộng dồn điểm cho từng đội
                        total[t] += score
        ```

    2\. Duyệt mảng `total` để tìm đội có điểm cao nhất.

    Trong C++, vì `total` là một `vector` nên ta có thể dùng hàm `max_element()` để lấy ra phần tử lớn nhất.

    Trong khi với Python, ta tự viết vòng lặp và hàm `enumerate()` để duyệt `total`.

    === "C++"

        ```c++ linenums="54"
            // Cho con duyệt it trỏ vào phần tử lớn nhất trong vector total
            vector<lli>::iterator it = max_element(total.begin(), total.end());

            // Lấy giá trị của phần tử lớn nhất đó
            max_score = *it;

            // Lấy chỉ số (vị trí) của phần tử lớn nhất đó
            max_team = distance(total.begin(), it) + 1;
        ```

    === "Python"

        ```py linenums="49"
            # Duyệt từng điểm tổng trong mảng total
            for i, score in enumerate(total):   
                if score > max_score:        
                    # Cập nhật tổng điểm cao nhất
                    max_score = score

                    # Cập nhật mã số của đội có điểm cao nhất
                    max_team = i + 1
        ```

### Mã nguồn

Code đầy đủ được đặt tại [GitHub](https://github.com/vtchitruong/hsg/tree/main/hsg9-tinh/2023-2024-camau/trochoi){:target="_blank"}.

## Bài 3: Số nguyên tố

### Đề bài

Số nguyên tố là số nguyên dương chỉ có duy nhất hai ước là 1 và chính nó.

**Yêu cầu:** Cho số nguyên $N (1 \le N \le 10^6)$ và $N$ đoạn số nguyên $[L_i, R_i]$ $(1 \le L_i < R_i \le 10^7; 1 \le i \le N)$. Hãy tìm số lượng số nguyên tố thuộc mỗi đoạn $[L_i, R_i]$.

**Đầu vào:** snt.inp

Dòng đầu tiên chứa số nguyên $N$.

$N$ dòng tiếp theo: dòng thứ i chứa hai số nguyên $L_i, R_i$.

**Đầu ra:** snt.out

Gồm N dòng, dòng thứ $i$ ghi một số nguyên là số lượng số nguyên tố thuộc đoạn $[L_i, R_i]$.

**Ví dụ:**

| snt.inp | snt.out |
| --- | --- |
| 2 <br> 14 16 <br> 11 25 | 0 <br> 5 |

Giải thích:

- Đoạn \[14, 16\]: không có số nguyên tố.
- Đoạn \[11, 25\]: có 5 số nguyên tố là 11, 13, 17, 19 và 23.

**Ràng buộc:**

- Có 40% số test tương ứng 40% số điểm của bài với $1 \le N \le 10^3; 1 \le L_i < R_i \le 10^3$.

- Có 60% số test tương ứng 60% số điểm của bài với $1 \le N \le 10^6; 1 \le L_i < R_i \le 10^7$. 

### Bài giải đề xuất

??? tip "Ý tưởng chính"

    1\. Vì giới hạn của `r` (right) là $10^7$ nên ta có thể sử dụng sàng Eratosthenes để đánh dấu các số nguyên tố từ $1$ đến $10^7$.

    2\. Để đếm số lượng số nguyên tố, ta dùng kỹ thuật *prefix sum* (*tổng tiền tố* hoặc *tổng cộng dồn*).

    Cụ thể, dùng mảng `prime_count` với `prime_count[i]` là số lượng số nguyên tố trong đoạn `[1, i]`.

    Như vậy, ta chỉ cần cập nhật mảng `prime_count` một vòng lặp duy nhất là có thể áp dụng cho mọi truy vấn `[l, r]` của input bằng công thức: `prime_count[r] - prime[l - 1]`.

??? tip "Viết chương trình"

    1\. Khai báo các biến liên quan.

    === "C++"

        ```c++ linenums="10"
        const int MAX = 1E7;

        int n, l, r;

        // Biến e lưu sàng Eratosthenes
        bitset<MAX + 1> e;

        // prime_count[i] lưu số lượng số nguyên tố từ 1 đến i
        vector<int> prime_count(MAX + 1, 0);
        ```

    === "Python"

        ```py linenums="8"
        MAX = 10000000

        n = l = r = 0

        # Khởi tạo sàng eratosthenes với toàn bộ phần tử đều là 1 (true)
        e = [1] * (MAX + 1)

        # prime_count[i] lưu số lượng số nguyên tố từ 1 đến i
        prime_count = [0] * (MAX + 1)
        ```

    2\. Viết hàm `sieve()` dùng để khởi tạo sàng Eratosthenes.

    === "C++"

        ```c++ linenums="21"
        void sieve()
        {
            // Khỏi tạo toàn bộ bit đều là 1
            e.set();

            // 0 và 1 không phải số nguyên tố
            e[0] = 0;
            e[1] = 0;

            // Duyệt từng số p trong phạm vi [2..sqrt(MAX)]
            for (int p = 2; p * p < MAX + 1; ++p)
            {
                if (e[p])
                {
                    // Nếu p là số nguyên tố thì đánh dấu 0 cho các bội của p, bắt đầu từ p * p
                    for (int i = p * p; i < MAX + 1; i += p)
                    {
                        e[i] = 0;
                    }
                }
            }
        }
        ```

    === "Python"

        ```py linenums="20"
        def sieve():
            global MAX, e

            # 0 và 1 không phải số nguyên tố
            e[0] = 0
            e[1] = 0

            # Duyệt từng số p trong phạm vi [2..sqrt(MAX)]
            for p in range(2, int(math.sqrt(MAX)) + 1):
                if e[p] == 1:
                    # Nếu p là số nguyên tố thì đánh dấu 0 cho các bội của p, bắt đầu từ p * p
                    for i in range(p * p, MAX + 1, p):
                        e[i] = 0
        ```

    3\. Viết hàm `prefix_sum()` dùng để tính tổng cộng dồn, lưu vô mảng `prime_count`.

    === "C++"

        ```c++ linenums="45"
        void prefix_sum()
        {
            for (int i = 1; i < MAX + 1; ++i)
            {
                prime_count[i] = prime_count[i - 1] + e[i];
            }
        }
        ```

    === "Python"

        ```py linenums="36"
        def prefix_sum():
            global e, prime_count

            for i in range(1, MAX + 1):
                prime_count[i] = prime_count[i - 1] + e[i]
        ```

    4\. Thực hiện vừa đọc truy vấn `l` và `r`, vừa xuất kết quả dựa trên mảng `prime_count`.

    === "C++"

        ```c++ linenums="54"
        void process()
        {
            // Khởi tạo sàng nguyên tố e
            sieve();

            // Tính mảng cộng dồn prime_count
            prefix_sum();

            ios_base::sync_with_stdio(false);
            cin.tie(NULL);

            freopen(input_file, "r", stdin);
            freopen(output_file, "w", stdout);

            cin >> n;

            int result;
            for (int q = 0; q < n; ++q)
            {
                cin >> l >> r;

                // Dựa vào prefix sum, in ra số lượng số nguyên tố trong phạm vi [l, r]
                result = prime_count[r] - prime_count[l - 1];
                cout << result << '\n';
            }
        }
        ```

    === "Python"

        ```py linenums="44"
        def process():
            global MAX, n, l, r, e, prime_count

            # Khởi tạo sàng nguyên tố e
            sieve()

            # Tính mảng cộng dồn prime_count
            prefix_sum()

            sys.stdin = open(input_file, 'r')
            sys.stdout = open(output_file, 'w')

            # Đọc toàn bộ dữ liệu vào bộ nhớ đệm và tách thành các token
            data = sys.stdin.read().split()

            iterator = iter(data)

            n = int(next(iterator))

            for _ in range(n):
                l = int(next(iterator))
                r = int(next(iterator))

                # Dựa vào prefix sum, in ra số lượng số nguyên tố trong phạm vi [l, r]
                result = prime_count[r] - prime_count[l - 1]
                print(result)
        ```

### Mã nguồn

Code đầy đủ được đặt tại [GitHub](https://github.com/vtchitruong/hsg/tree/main/hsg9-tinh/2023-2024-camau/snt){:target="_blank"}.