# 2014-2015 Olympic 11

## Bài 1: Thả diều (5 điểm)

### Đề bài

Trong cuộc thi thả diều nhanh, ban tổ chức đưa ra thể lệ cuộc thi như sau: Những chiếc diều không được thả cùng một lúc, mà thả theo trình tự đăng ký nhanh. Khi một chiếc diều được thả lên trời, ban giám khảo căn cứ vào độ cao của chiếc diều và xếp hạng cho chiếc diều đó bằng cách so độ cao của nó với độ cao của những chiếc diều đã thả trước đó.

Chẳng hạn: Độ cao của 4 chiếc diều theo thứ tự được thả như sau: 78 24 68 40. Chiếc diều đầu tiên được xếp hạng nhất vì trước nó chưa có chiếc diều nào được thả. Chiếc diều thứ hai xếp hạng 2 vì 24 < 78. Chiếc diều thứ ba cũng xếp hạng 2 vì 24 < 68 < 78. Chiếc diều thứ tư xếp hạng 3 vì 24 < 40 < 68 < 78. Thứ tự công bố là: 1 2 2 3.

**Yêu cầu**: Có N chiếc diều lần lượt được thả, hãy cho biết dãy số biểu diễn giá trị xếp hạng của các chiếc diều.

**Dữ liệu vào:** Cho từ file văn bản `KITE.INP` có cấu trúc:

- Dòng thứ nhất ghi số nguyên dương N cho biết số chiếc diều tham gia dự thi.
- N dòng tiếp theo, mỗi dòng ghi một số nguyên dương mô tả độ cao của một chiếc diều, theo thứ tự mà nó được thả lên.

**Kết quả:** Ghi vào file văn bản `KITE.OUT` có cấu trúc gồm N dòng, dòng thứ i ghi số nguyên biểu diễn giá trị xếp hạng của chiếc diều thứ i tại thời điểm nó được thả lên.

**Ví dụ:**

| KITE.INP  | KITE.OUT |
| --- | --- |
| 4 <br> 78 <br> 24 <br> 68 <br> 40 | 1 <br> 2 <br> 2 <br> 3|

**Hạn chế kỹ thuật**:

- $N \le 45000$ và không có hai chiếc diều nào có cùng độ cao.
- Độ cao của mỗi chiếc diều là một số nguyên dương không vượt quá $2^{31}$.

### Bài giải đề xuất

#### Ý tưởng chính

1\. Với mỗi lần thả chiều diều mới, độ cao của diều mới được đưa vào vị trí sao cho thứ tự tăng dần theo độ cao của các chiều diều vẫn được bảo đảm.    

- Trong C++, kiểu dữ liệu hỗ trợ tự động sắp xếp là `set`. Sau khi chèn độ cao của diều mới, thứ tự của các độ cao vẫn được bảo đảm tăng dần.

- Trong Python, do kiểu `set` không hỗ trợ tự động sắp xếp, ta phải tự viết hàm để tìm vị trí chèn diều mới vào và bảo đảm thứ tự danh sách là giảm dần sau khi chèn.

2\. Như vậy, ta thực hiện đồng thời việc thêm từng độ cao vào tập hợp hoặc danh sách và xếp hạng ngay độ cao vừa thêm vào. 

- Trong C++, do thứ tự là tăng dần, độ cao cao nhất, tức hạng 1, nằm ở cuối tập hợp. Vì thế, ta cần so sánh các độ cao khác với độ cao nằm ở vị trí cuối để xếp hạng.

- Trong Python, do danh sách có thứ tự giảm dần, ta tính thứ hạng bằng cách dựa vào chỉ số.

#### Viết chương trình

**1\. Khởi tạo**

Gọi `heights` là tập hợp (C++) hoặc danh sách (Python) chứa các độ cao tăng dần, `result` là mảng lưu các thứ hạng để output.

Nạp độ cao đầu tiên vào `heights` và nạp thứ hạng 1 vào `result`.  

=== "C++"

    ```c++ linenums="28"
        // Đọc độ cao của diều đầu tiên
        int h;    
        cin >> h;
        heights.insert(h);

        // Diều đầu tiên được xếp hạng 1
        result.push_back(1);
    ```
=== "Python"

    ```py linenums="35"
        # Đọc độ cao của diều đầu tiên
        h = int(f.readline())
        heights.append(h)

        # Diều đầu tiên được xếp hạng 1
        rank = 1
        result.append(rank)
    ```

**2\. Xử lý**

Lần lượt đọc từng độ cao còn lại, ứng với từng độ cao `h`, lặp thao tác:

- Nạp `h` vào `heights`.
- Tính thứ hạng của `h` và nạp và mảng `result`.

=== "C++"

    ```c++ linenums="36"
        // Thứ hạng của mỗi diều
        int rank;

        // Duyệt từng dòng còn lại của dữ liệu đầu vào
        for (int i = 1; i < n; ++i)
        {
            // Đọc độ cao của một diều mới
            cin >> h;

            // Nạp vào set heights
            heights.insert(h);

            // Tính thứ hạng của h vừa nạp bằng cách so vị trí với phần tử cuối cùng trong set
            rank = distance(heights.find(h), heights.end()); // (1)!

            // Ghi nhận thứ hạng
            result.push_back(rank);
        }
    ```
    { .annotate }

    1.  Hàm `std::distance()` dùng để tính số lượng phần tử nằm giữa hai iterator.


=== "Python"

    ```py linenums="43"
        # Duyệt từng dòng còn lại của dữ liệu đầu vào
        for i in range(1, n):
            # Đọc độ cao của một diều mới
            h = int(f.readline())

            # Xác định vị trí sẽ chèn vào
            pos_to_insert = position(heights, h)

            # Nếu không có vị trí chèn phù hợp
            if pos_to_insert == -1:
                # thì thêm vào cuối danh sách heights
                heights.append(h)
            else:
                heights.insert(pos_to_insert, h)

            # Tính thứ hạng của h vừa nạp bằng cách dựa vào chỉ số
            rank = heights.index(h) + 1

            # Ghi nhận thứ hạng
            result.append(rank)
    ```

    Trong đó, hàm `position()` dùng để tìm vị trí sẽ chèn vào độ cao mới và bảo đảm thứ tự của danh sách luôn giảm dần.

    ```py linenums="17"
    def position(A, value):
        # Duyệt từng phần tử trong danh sách A
        for i, element in enumerate(A):
            # Nếu gặp phần tử nhỏ hơn
            if element < value:
                # thì trả về vị trí của phần tử đó
                return i
        
        # Ngược lại, không có phần tử nhỏ hơn, thì trả về -1
        return -1
    ```

## Mã nguồn

Code đầy đủ được đặt tại [GitHub](https://github.com/vtchitruong/hsg/tree/main/olympic-hcm/2015-olympic11/kite){:target="_blank"}.